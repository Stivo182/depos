#Использовать fs

#Область ОписаниеПеременных

Перем _Зависимости; // ТаблицаЗначений, Неопределено
Перем _ИмяФайлаМанифеста; // Строка, Неопределено
Перем _КаталогМанифеста; // Строка, Неопределено
Перем _КаталогиИсходников; // Массив из Строка
Перем _КаталогиСлужебныхИсходников; // Массив из Строка
Перем _ИсключитьЗависимостиДляРазработки; // Булево
Перем _ИспользуемыеПакеты; // ТаблицаЗначений
Перем _РезультатАнализа; // РезультатАнализа

&Пластилин("СканерИсходников")
Перем _СканерИсходников; // СканерИсходников

&Пластилин("ПомощникМанифеста")
Перем _ПомощникМанифеста; // ПомощникМанифеста

#КонецОбласти

#Область Конструктор

&Желудь
&Характер("Компанейский")
Процедура ПриСозданииОбъекта()

	_КаталогиИсходников = Новый Массив();
	_КаталогиСлужебныхИсходников = Новый Массив();

	_ИспользуемыеПакеты = Новый ТаблицаЗначений();
	_ИспользуемыеПакеты.Колонки.Добавить("ИмяПакета", Новый ОписаниеТипов("Строка"));
	_ИспользуемыеПакеты.Колонки.Добавить("ДляРазработки", Новый ОписаниеТипов("Булево"));
	_ИспользуемыеПакеты.Колонки.Добавить("Файлы");

	ИсключитьЗависимостиДляРазработки(Ложь);

КонецПроцедуры

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Устанавливает зависимости из переданной таблицы.
//
// Параметры:
//   Зависимости - ТаблицаЗначений - Таблица с данными о зависимостях пакетов:
//     * ИмяПакета - Строка - Имя пакета
//     * ДляРазработки - Булево - Признак зависимости для разработки
//     * МинимальнаяВерсия - Строка - Текущая минимальная версия
//     * МаксимальнаяВерсия - Строка - Текущая максимальная версия
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция ИзТаблицы(Зависимости) Экспорт
	
	_Зависимости = Зависимости.Скопировать(, "ИмяПакета, ДляРазработки, МинимальнаяВерсия, МаксимальнаяВерсия");
	_ИмяФайлаМанифеста = Неопределено;
	_КаталогМанифеста = Неопределено;

	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает путь к файлу манифеста для чтения зависимостей.
//
// Параметры:
//   Файл - Строка - Путь к файлу манифеста
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция ИзФайла(Файл) Экспорт

	_Зависимости = Неопределено;
	_ИмяФайлаМанифеста = Файл;
	_КаталогМанифеста = ?(ФС.КаталогСуществует(_ИмяФайлаМанифеста),
		_ИмяФайлаМанифеста, 
		Новый Файл(_ИмяФайлаМанифеста).Путь
	);
	
	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает признак исключения зависимостей для разработки из анализа.
//
// Параметры:
//   Исключить - Булево - Признак исключения зависимостей для разработки.
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция ИсключитьЗависимостиДляРазработки(Исключить = Истина) Экспорт
	_ИсключитьЗависимостиДляРазработки = Исключить;
	Возврат ЭтотОбъект;
КонецФункции

// Устанавливает каталоги с исходниками для анализа использования пакетов.
//
// Относительные пути разрешаются:
//   - относительно каталога манифеста (если файл манифеста задан)
//   - относительно текущего рабочего каталога (если файл манифеста не задан)
//
// Параметры:
//   Каталоги - Массив из Строка, Строка - Массив путей к каталогам с исходниками
//                                         или строка с путями, разделенными запятыми.
//                                         Поддерживаются абсолютные и относительные пути.
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция УстановитьИсходники(Каталоги) Экспорт

	_КаталогиИсходников.Очистить();
	УстановитьКаталоги(Каталоги, _КаталогиИсходников);

	Возврат ЭтотОбъект;

КонецФункции

// Устанавливает каталоги со служебными исходниками для анализа использования пакетов.
//
// Определяет каталоги со служебным кодом (тесты, примеры, инструменты сборки),
// в которых будет выполняться поиск использования пакетов. Пакеты, найденные
// в этих каталогах, помечаются как используемые для разработки.
//
// Относительные пути разрешаются:
//   - относительно каталога манифеста (если файл манифеста задан)
//   - относительно текущего рабочего каталога (если файл манифеста не задан)
//
// Параметры:
//   Каталоги - Массив из Строка, Строка - Массив путей к каталогам со служебными исходниками
//                                         или строка с путями, разделенными запятыми.
//                                         Поддерживаются абсолютные и относительные пути.
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция УстановитьСлужебныеИсходники(Каталоги) Экспорт

	_КаталогиСлужебныхИсходников.Очистить();
	УстановитьКаталоги(Каталоги, _КаталогиСлужебныхИсходников);

	Возврат ЭтотОбъект;

КонецФункции

// Анализирует зависимости и выявляет ошибки.
//
// Возвращаемое значение:
//   РезультатАнализа - Результат анализа, содержащий найденные ошибки
Функция НайтиОшибки() Экспорт
	
	_РезультатАнализа = Новый РезультатАнализа();
	_ИспользуемыеПакеты.Очистить();

	ПодготовитьЗависимости();

	ДобавитьИспользуемыеПакеты(
		_СканерИсходников.НайтиПакеты(ПолучитьКаталогиОтносительноМанифеста(_КаталогиИсходников)), 
		Ложь
	);
	ДобавитьИспользуемыеПакеты(
		_СканерИсходников.НайтиПакеты(ПолучитьКаталогиОтносительноМанифеста(_КаталогиСлужебныхИсходников)),
		 Истина
	);
	
	АнализироватьОтсутствующиеЗависимости();
	АнализироватьНеиспользуемыеЗависимости();
	
	Возврат _РезультатАнализа;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура УстановитьКаталоги(Источник, Приемник)
		
	Приемник.Очистить();

	ИсточникМассив = Источник;
	Если ТипЗнч(ИсточникМассив) = Тип("Строка") Тогда
		ИсточникМассив = СтрРазделить(ИсточникМассив, ",", Ложь);
	КонецЕсли;

	Для Каждого Каталог Из ИсточникМассив Цикл
		Приемник.Добавить(Каталог);
	КонецЦикла;

КонецПроцедуры

Процедура ДобавитьИспользуемыеПакеты(Пакеты, ДляРазработки)
	
	Для Каждого Пакет Из Пакеты Цикл

		Отбор = Новый Структура("ИмяПакета, ДляРазработки", Пакет.ИмяПакета, ДляРазработки);
		НайденныеСтроки = _ИспользуемыеПакеты.НайтиСтроки(Отбор);

		Если НайденныеСтроки.Количество() = 0 Тогда
			СтрокаТаблицы = _ИспользуемыеПакеты.Добавить();
			СтрокаТаблицы.ИмяПакета = Пакет.ИмяПакета;
			СтрокаТаблицы.ДляРазработки = ДляРазработки;
			СтрокаТаблицы.Файлы = Новый Массив();
		Иначе
			СтрокаТаблицы = НайденныеСтроки[0];
		КонецЕсли;

		СтрокаТаблицы.Файлы.Добавить(Пакет.Файл);

	КонецЦикла;

КонецПроцедуры

Процедура ПодготовитьЗависимости()
		
	Если ЗначениеЗаполнено(_ИмяФайлаМанифеста) Тогда
		_Зависимости = _ПомощникМанифеста.ПрочитатьЗависимостиИзМанифеста(_ИмяФайлаМанифеста);
	КонецЕсли;

	Если _Зависимости = Неопределено Тогда
		ВызватьИсключение "Не указан источник зависимостей (файл манифеста или таблица).";
	КонецЕсли;

КонецПроцедуры

Процедура АнализироватьОтсутствующиеЗависимости()
	
	Для Каждого ИспользуемыйПакет Из _ИспользуемыеПакеты Цикл

		Если _ИсключитьЗависимостиДляРазработки И ИспользуемыйПакет.ДляРазработки Тогда
			Продолжить;
		КонецЕсли;

		Отбор = Новый Структура();
		Отбор.Вставить("ИмяПакета", ИспользуемыйПакет.ИмяПакета); 
		
		Если Не ИспользуемыйПакет.ДляРазработки Тогда
			Отбор.Вставить("ДляРазработки", ИспользуемыйПакет.ДляРазработки); 
		КонецЕсли;
			
		Если _Зависимости.НайтиСтроки(Отбор).Количество() > 0 Тогда
			Продолжить;
		КонецЕсли;

		СтрокаРезультата = _РезультатАнализа.ОтсутствующиеПакеты.Добавить();
		СтрокаРезультата.ИмяПакета = ИспользуемыйПакет.ИмяПакета;
		СтрокаРезультата.ДляРазработки = ИспользуемыйПакет.ДляРазработки;
		СтрокаРезультата.Файлы = ИспользуемыйПакет.Файлы;
		
	КонецЦикла;

КонецПроцедуры

Процедура АнализироватьНеиспользуемыеЗависимости()
	
	Для Каждого Зависимость Из _Зависимости Цикл

		Если _ИсключитьЗависимостиДляРазработки И Зависимость.ДляРазработки Тогда
			Продолжить;
		КонецЕсли;

		Отбор = Новый Структура("ИмяПакета, ДляРазработки", Зависимость.ИмяПакета, Зависимость.ДляРазработки);
		
		Если _ИспользуемыеПакеты.НайтиСтроки(Отбор).Количество() > 0 Тогда
			Продолжить;
		КонецЕсли;

		СтрокаРезультата = _РезультатАнализа.НеиспользуемыеПакеты.Добавить();
		СтрокаРезультата.ИмяПакета = Зависимость.ИмяПакета;
		СтрокаРезультата.ДляРазработки = Зависимость.ДляРазработки;
		
	КонецЦикла;

КонецПроцедуры

Функция ПолучитьКаталогиОтносительноМанифеста(Каталоги)

	Если Не ЗначениеЗаполнено(_КаталогМанифеста) Тогда
		Возврат Каталоги;
	КонецЕсли;

	Результат = Новый Массив();
	Для Каждого Каталог Из Каталоги Цикл

		Каталог = СокрЛП(Каталог);

		Если ЭтоОтносительныйПуть(Каталог) Тогда
			Результат.Добавить(ФС.ПолныйПуть(ОбъединитьПути(_КаталогМанифеста, Каталог)));
		Иначе
			Результат.Добавить(Каталог);
		КонецЕсли;

	КонецЦикла;

	Возврат Результат;

КонецФункции

Функция ЭтоОтносительныйПуть(Путь)

	СистемнаяИнформация = Новый СистемнаяИнформация();

	Если СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
		Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		Возврат Не (СтрНачинаетсяС(Путь, "\\") Или СтрНайти(Путь, ":"));
	Иначе
		Возврат Не СтрНачинаетсяС(Путь, "/");
	КонецЕсли;

КонецФункции

#КонецОбласти
