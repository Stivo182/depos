#Использовать semver
#Использовать "../../internal"

#Область ОписаниеПеременных

Перем _Зависимости; // ТаблицаЗначений, Неопределено
Перем _ТолькоУстаревшие; // Булево
Перем _ТипВерсии; // Строка, Неопределено
Перем _ИмяПакета; // Строка, Неопределено
Перем _РегулярноеВыражениеИмениПакета; // РегулярноеВыражение, Неопределено
Перем _РегулярноеВыражениеРазделителей; // РегулярноеВыражение
Перем _РегулярноеВыражениеЭкранирования; // РегулярноеВыражение
Перем _ИмяФайлаМанифеста; // Строка, Неопределено

&Пластилин("ОпределительВерсийПакетов")
Перем _ОпределительВерсийПакетов; // ОпределительВерсийПакетов

&Пластилин("ПомощникМанифеста")
Перем _ПомощникМанифеста; // ПомощникМанифеста

#КонецОбласти

#Область Конструктор

&Желудь
&Характер("Компанейский")
Процедура ПриСозданииОбъекта()

	ТолькоУстаревшие(Ложь);
	УстановитьТипВерсии(ТипыВерсий.Последняя);
	
	_РегулярноеВыражениеРазделителей = Новый РегулярноеВыражение("[\s,]+");
	_РегулярноеВыражениеЭкранирования = Новый РегулярноеВыражение("[\\^$.*+?()[\]{}|]");

КонецПроцедуры

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Устанавливает зависимости из переданной таблицы.
//
// Параметры:
//   Зависимости - ТаблицаЗначений - Таблица с данными о зависимостях пакетов:
//     * ИмяПакета - Строка - Имя пакета
//     * ДляРазработки - Булево - Признак зависимости для разработки
//     * МинимальнаяВерсия - Строка - Текущая минимальная версия
//     * МаксимальнаяВерсия - Строка - Текущая максимальная версия
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция УстановитьТаблицуЗависимостей(Зависимости) Экспорт
	_Зависимости = Зависимости.Скопировать(, "ИмяПакета, ДляРазработки, МинимальнаяВерсия, МаксимальнаяВерсия");
	_ИмяФайлаМанифеста = Неопределено;
	Возврат ЭтотОбъект;
КонецФункции

// Устанавливает путь к файлу манифеста для чтения зависимостей.
//
// Параметры:
//   Файл - Строка - Путь к файлу манифеста
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция УстановитьФайлМанифеста(Файл) Экспорт
	_ИмяФайлаМанифеста = Файл;
	_Зависимости = Неопределено;
	Возврат ЭтотОбъект;
КонецФункции

// Устанавливает фильтр по устаревшим пакетам.
//
// Параметры:
//   Включить - Булево - Если Истина, возвращаются только пакеты с устаревшими версиями
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция ТолькоУстаревшие(Включить = Истина) Экспорт
	_ТолькоУстаревшие = Включить;
	Возврат ЭтотОбъект;
КонецФункции

// Устанавливает фильтр по имени пакета.
//
// Параметры:
//   ИмяПакета - Строка - Имена пакетов через запятую или пробел, маска (поддерживает * и ?)
//                        или регулярное выражение (например, /^autumn-.*$/).
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция ФильтроватьПоИмени(Знач ИмяПакета) Экспорт
	_ИмяПакета = ИмяПакета;
	_РегулярноеВыражениеИмениПакета = Неопределено;
	Возврат ЭтотОбъект;
КонецФункции

// Устанавливает тип целевой версии для определения версий пакетов.
//
// Параметры:
//   ТипВерсии - Строка - Тип версии (см. ТипыВерсий)
//
// Возвращаемое значение:
//   ЭтотОбъект - Для поддержки цепочки вызовов
Функция УстановитьТипВерсии(ТипВерсии) Экспорт
	_ТипВерсии = ТипВерсии;
	Возврат ЭтотОбъект;
КонецФункции

// Возвращает отфильтрованные зависимости с целевыми версиями.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Таблица с колонками:
//     * ИмяПакета - Строка - Имя пакета
//     * ДляРазработки - Булево - Признак зависимости для разработки
//     * МинимальнаяВерсия - Строка - Текущая минимальная версия
//     * МаксимальнаяВерсия - Строка - Текущая максимальная версия
//     * ЦелеваяВерсия - Строка - Целевая версия
Функция ПолучитьЗависимости() Экспорт

	Если ЗначениеЗаполнено(_ИмяФайлаМанифеста) Тогда
		УстановитьТаблицуЗависимостей(_ПомощникМанифеста.ПрочитатьЗависимостиИзМанифеста(_ИмяФайлаМанифеста));
	КонецЕсли;

	Если _Зависимости = Неопределено Тогда
		ВызватьИсключение "Не указан источник зависимостей (файл манифеста или таблица).";
	КонецЕсли;

	Если _РегулярноеВыражениеИмениПакета = Неопределено Тогда
		ПодготовитьРегулярноеВыражениеИмениПакета();
	КонецЕсли;

	ОтобранныеЗависимости = ПолучитьОтобранныеЗависимости();
	ЦелевыеВерсииПакетов = _ОпределительВерсийПакетов.НайтиВерсии(ОтобранныеЗависимости, _ТипВерсии);

	Результат = ПустаяТаблицаРезультата();

	Для Каждого СтрокаЗависимости Из ОтобранныеЗависимости Цикл

		Версия = ЦелевыеВерсииПакетов[СтрокаЗависимости.ИмяПакета];

		ВерсияБольшеМинимальной = ЗначениеЗаполнено(Версия) 
			И ЗначениеЗаполнено(СтрокаЗависимости.МинимальнаяВерсия)
			И Версии.ВерсияБольше(Версия, Новый Версия(СтрокаЗависимости.МинимальнаяВерсия));
		
		Если Не _ТолькоУстаревшие Или ВерсияБольшеМинимальной Тогда
			СтрокаРезультат = Результат.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаРезультат, СтрокаЗависимости);
			СтрокаРезультат.ЦелеваяВерсия = Версия;
		КонецЕсли;

	КонецЦикла;

	Результат.Сортировать("ДляРазработки, ИмяПакета");

	Возврат Результат;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПолучитьОтобранныеЗависимости() Экспорт

	ОтобранныеЗависимости = _Зависимости.Скопировать(Новый Массив());

	Для Каждого СтрокаТаблицы Из _Зависимости Цикл
		Если СовпадаетИмяПакета(СтрокаТаблицы.ИмяПакета) Тогда
			ЗаполнитьЗначенияСвойств(ОтобранныеЗависимости.Добавить(), СтрокаТаблицы);
		КонецЕсли;
	КонецЦикла;

	Возврат ОтобранныеЗависимости;

КонецФункции

Функция СовпадаетИмяПакета(ИмяПакета)
	
	Если _РегулярноеВыражениеИмениПакета = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;

	Возврат _РегулярноеВыражениеИмениПакета.Совпадает(ИмяПакета);

КонецФункции

Функция ПустаяТаблицаРезультата()
	
	ТипСтрока = Новый ОписаниеТипов("Строка");

	Результат = Новый ТаблицаЗначений();
	Результат.Колонки.Добавить("ИмяПакета", ТипСтрока);
	Результат.Колонки.Добавить("ДляРазработки", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("МинимальнаяВерсия", ТипСтрока);
	Результат.Колонки.Добавить("МаксимальнаяВерсия", ТипСтрока);
	Результат.Колонки.Добавить("ЦелеваяВерсия", ТипСтрока);

	Возврат Результат;

КонецФункции

Процедура ПодготовитьРегулярноеВыражениеИмениПакета()

	Если Не ЗначениеЗаполнено(_ИмяПакета) Тогда
		Возврат;
	КонецЕсли;

	ИмяПакета = СокрЛП(_ИмяПакета);
	ЭтоРегулярноеВыражение = Лев(ИмяПакета, 1) = "/" И Прав(ИмяПакета, 1) = "/";

	Если ЭтоРегулярноеВыражение Тогда
		Паттерн = Сред(ИмяПакета, 2, СтрДлина(ИмяПакета) - 2);
	Иначе
		Паттерн = ОбработатьМаскиИИменаПакетов(ИмяПакета);
	КонецЕсли;
	
	_РегулярноеВыражениеИмениПакета = Новый РегулярноеВыражение(Паттерн);

КонецПроцедуры

// Обрабатывает маски и имена пакетов для создания регулярного выражения
//
// Параметры:
//   ИмяПакета - Строка - Имя пакета с возможными масками и разделителями
//
// Возвращаемое значение:
//   Строка - Готовый паттерн для регулярного выражения
Функция ОбработатьМаскиИИменаПакетов(ИмяПакета)
	
	Паттерн = СокрЛП(ИмяПакета);
	
	// Экранируем специальные символы регулярных выражений
	Паттерн = ЭкранироватьСлужебныеСимволыДляРегулярногоВыражения(Паттерн);
	
	// Заменяем маски на соответствующие регулярные выражения
	Паттерн = СтрЗаменить(Паттерн, "\*", ".*");
	Паттерн = СтрЗаменить(Паттерн, "\?", ".?");
	
	// Обрабатываем разделители
	Паттерн = НормализоватьРазделителиДляРегулярногоВыражения(Паттерн);
	
	// Оборачиваем в якоря начала и конца строки
	Возврат СтрШаблон("^(%1)$", Паттерн);
	
КонецФункции

Функция НормализоватьРазделителиДляРегулярногоВыражения(Паттерн)
	Возврат _РегулярноеВыражениеРазделителей.Заменить(Паттерн, "|");
КонецФункции

Функция ЭкранироватьСлужебныеСимволыДляРегулярногоВыражения(Строка)
	Возврат _РегулярноеВыражениеЭкранирования.Заменить(Строка, "\$0");
КонецФункции

#КонецОбласти